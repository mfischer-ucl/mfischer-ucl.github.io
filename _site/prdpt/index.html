<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Michael Fischer</title>
<meta name="description" content="Michael Fischer, PhD Student in AI and Computer Graphics at University College London (UCL).">


  <meta name="author" content="Michael Fischer">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Michael Fischer">
<meta property="og:title" content="Michael Fischer">
<meta property="og:url" content="http://localhost:4000/prdpt/">


  <meta property="og:description" content="Michael Fischer, PhD Student in AI and Computer Graphics at University College London (UCL).">












<link rel="canonical" href="http://localhost:4000/prdpt/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Michael Fischer Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">
<link rel="stylesheet" href="/assets/css/academicons.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Michael Fischer
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/">Home</a>
            </li><li class="masthead__menu-item">
              <a href="/news/">News</a>
            </li><li class="masthead__menu-item">
              <a href="/publications/">Publications</a>
            </li><li class="masthead__menu-item">
              <a href="/contact/">Contact</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          
          


        </header>
      

      <section class="page__content e-content" itemprop="text">
        
        
<style>

.row {
  margin-left: -15px;
  margin-right: -15px;
}

h4, .h4, h5, .h5, h6, .h6 {
  margin-top: 10.5px;
  margin-bottom: 10.5px;
}

.horizItem {
    display: inline-block; 
    margin-left: 3%; 
    margin-right: 3%;
}

.grey-box {
  background-color: #f2f2f2;
  padding: 20px;
  box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
  border-radius: 10px;
}

figure{
display: inline-block;
}

.cite-box {
  background-color: #f7f7f7; 
  line-height: 110%;
  box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); 
  border-radius: 3px;
  padding: 10px;
}

.vidcontainer {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  margin-bottom: 15px;
}

.teaserbutton {
  height: 80px;
}

.globaldiv {
    font-size: 16px; 
    margin-left: -25%;
}

@media screen and (max-width: 768px) {
    
    .grey-box {
        max-width: 100%;
    }

    .cite-box {
        max-width: 100%;
    }    

    .vidcontainer {
        max-width: 100%;
    }

    .globaldiv {
        max-width: 100%;
        margin-left: 0%;
    }
}

</style>

<body>
<div class="globaldiv">

<div class="grey-box">
<br />
    <p style="margin: 0 auto; text-align: center;">
    <span style="font-size: 24px;"><b>Plateau-Reduced Differentiable Path Tracing</b></span> <br /><br />
    <span style="font-size: 17px; color: black">CVPR 2023</span><br /><br />
    <span style="font-size: 17px;"><a href="https://mfischer-ucl.github.io/">Michael Fischer</a>, <a href="https://www.homepages.ucl.ac.uk/~ucactri/">Tobias Ritschel</a></span><br />
    <a style="font-size: 14px;" href="https://www.ucl.ac.uk/">University College London</a>
</p>
<br />
</div>

<!--<div style="display: flex; justify-content: center; align-items: center; margin-top: 2%">
  <img src="/assets/images/prdpt/teaserImg1.png" style="width: 100%">
</div>-->

<div class="row" style="margin: 50px 0 50px 0">
    <div style="display: inline">
        <ul style="list-style: none; text-align: center">
            <li class="horizItem">
                <a href="/assets/prdpt_main.pdf" download="plateaureduced_diff_pt.pdf">
                <img class="teaserbutton" src="/assets/images/prdpt/paperfront.png" /><br />
                    <h4><strong>Paper</strong></h4>
                </a>
            </li>
            <li class="horizItem">
                <a href="https://youtu.be/KJlJbqJ4wwY">
                <img class="teaserbutton" src="/assets/images/youtube_icon_red.png" /><br />
                    <h4><strong>Video</strong></h4>
                </a>
            </li>
            <li class="horizItem">
                <a href="https://github.com/mfischer-ucl/prdpt">
                <img class="teaserbutton" src="/assets/images/gh_icon.png" /><br />
                    <h4><strong>Code</strong></h4>
                </a>
            </li>
            <li class="horizItem">
                <a href="https://colab.research.google.com/github/mfischer-ucl/prdpt/blob/main/examples/box_example.ipynb">
                <img class="teaserbutton" src="/assets/images/colablogo.png" /><br />
                    <h4><strong>Colab</strong></h4>
                </a>
            </li>
            <li class="horizItem">
                <a href="/assets/prdpt_suppl.pdf" download="plateaureduced_diff_pt_suppl.pdf">
                <img class="teaserbutton" src="/assets/images/paperclip.png" /><br />
                    <h4><strong>Supplemental</strong></h4>
                </a>
            </li>
        </ul>
    </div>
</div>

<b>TL;DR:</b><br />
<p style="text-align: justify">
We convolute the traditional rendering equation with a Gaussian smoothing kernel to reduce plateaus, i.e., regions of zero gradient, in inverse 
rendering. Our algorithm improves convergence and works on problems with intricate light transport (e.g., caustics) that previous algorithms
do not converge on.</p>

<b>Abstract</b><br />
<p style="text-align: justify">
Current differentiable renderers provide light transport
gradients with respect to arbitrary scene parameters. However,
the mere existence of these gradients does not guarantee
useful update steps in an optimization. Instead, inverse
rendering might not converge due to inherent plateaus, i.e.,
regions of zero gradient, in the objective function. We propose
to alleviate this by convolving the high-dimensional
rendering function, that maps scene parameters to images,
with an additional kernel that blurs the parameter
space. We describe two Monte Carlo estimators to compute
plateau-reduced gradients efficiently, i.e., with low variance,
and show that these translate into net-gains in optimization
error and runtime performance. Our approach
is a straightforward extension to both black-box and differentiable
renderers and enables optimization of problems
with intricate light transport, such as caustics or global
illumination, that existing differentiable renderers do not
converge on.</p>

<p style="display: block; margin-left: auto; margin-right: auto; max-width: 75%">
<iframe width="560" height="315" src="https://www.youtube.com/embed/KJlJbqJ4wwY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; 
clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="">
</iframe>
</p>

<b>Interactive Examples</b><br />
<p style="text-align: justify">
Below is an interactive 1D example which uses our method to differentiate through a discontinuous step function. The task here 
is to move the triangle center (parameterized by theta), such that it covers the black pixel at the bottom. The plateaus in the cost landscape 
come from the fact that the error between the pixel's desired and its current color does not take into account how "far away" the triangle is 
when it's not overlapping the pixel. We can smoothen these plateaus by our proposed convolution with a Gaussian kernel (displayed in plot in the right bottom corner, click 'Show Smooth' to see the convolved function). 
We then sample this convoluted space and use the samples to drive a gradient descent that moves the initial 
parameter (green) towards the region of zero cost, i.e., such that the triangle overlaps the pixel. <br />
</p>

<style>
  #plot-container-wrapper {
    background-color: rgba(240, 240, 240, 0.5);
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
    padding: 20px;
    justify-content: space-between;
    height: 640px;
    display: flex; 
  }
  #plot-container {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
  }
  #plot-container2 {
    display: flex;
    justify-content: space-between;
  }
  #plot-container3 {
    display: flex;
    justify-content: space-between;
  }
  #plot {
    width: 100%;
    height: 80%;
  }
  #plot2 {
    width: 100%;
    aspect-ratio: 2 / 1.09;
  }
  #plot3 {
    width: 100%;
    height: 18%;
  }
  .slider {
    margin-left: 5%;
    width: 30%;
  }
  .slider-container{
    width: 400px;
  }
  .textbox {
    border-style: solid; 
    box-shadow: inset 0px 0px 0px 0px black; 
    border: none; 
    background-color: transparent;
  }

@media screen and (max-width: 768px) {
    #plot-container-wrapper {
        max-width: 100%;
    }
    #plot-container {
        max-width: 100%;
    }
    #plot-container2 {
        max-width: 100%;
    }
    #plot-container3 {
        max-width: 100%;
    }
    #plot {
        max-width: 100%;
    }
    #plot2 {
        max-width: 100%;
    }
    #plot3 {
        max-width: 100%;
    }
    .slider-container {
        max-width: 100%;
    }
}

</style>

<div id="plot-container-wrapper">
    <div id="plot-container">
      <div id="plot"></div>
      <div id="plot3"></div>
    </div>
    <div id="plot-container">
      <div class="slider-container">       <!-- the slider container-->
        <div style="display: flex">
          <label for="sigma">Sigma:</label>
          <input class="slider" type="range" min="0.33" max="2.5" step="0.01" value="1" id="sigma" />
        </div>
        <div style="display: flex">
          <label for="num-samples">Num Samples:</label>
          <input class="slider" type="range" min="2" max="100" step="2" value="10" id="num-samples" />
        </div>
        <div style="display: flex">
          <label for="theta">Theta:</label>
          <input class="slider" type="range" min="-4" max="4.0" step="0.1" value="-1.8" id="theta" />
        </div>
        <div style="display: flex">
          <label for="stepsize">StepSize:</label>
          <input class="slider" type="range" min="0.001" max="0.5" step="0.01" value="0.1" id="stepsize" />
        </div>
        <div style="display: flex">
          <label for="epochs">Epochs:</label>
          <input class="slider" type="range" min="10" max="700" step="1" value="200" id="epochs" />
        </div>
        <div style="display: flex">
            <input type="checkbox" id="cb_antithetic" checked="" />
            <div style="margin-left: 10px;">Antithetic?</div>
        </div>
        <div style="display: flex">
            <input type="checkbox" id="cb_showsmoothed" />
            <div style="margin-left: 10px;">Show Smooth?</div>
        </div>
        <div style="display: flex;">
          <button style="float: left; margin-top: 14px;" onclick="optimize()">Run Optimization</button>
          <button style="float: left; margin-left: 10px; margin-top: 14px;" onclick="stop_anim()">Stop</button>
          <button style="float: left; margin-left: 10px; margin-top: 14px;" onclick="reset()">Reset</button>
        </div>
        _______________________________________
        <div style="display: flex; margin-top: 10px">
            <input type="text" class="textbox" id="epoch_text" value="Current Epoch: 0" />
        </div>
        <div style="display: flex">
            <input type="text" class="textbox" id="cost_text" value="Current Cost: 1.0" />
        </div>
        <div id="plot2" style="width: 100%;"></div>
      </div>
    </div>
</div>

<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script>
  
function stepEdge(x) {
	return x < -0.5 ? 1 : (x > 2.5 ? 1 : 0); 
}

function calcGradGaussian(x, sigma) {
		// already sampling the positivized function here 
    return (Math.abs(x) / Math.pow(sigma, 2)) * calcGaussian(x, sigma=sigma);
}

function gradGaussianKernel(x, sigma) {
	return -(x / Math.pow(sigma, 2)) * calcGaussian(x, sigma=sigma);
}

function get_pdf(x, sigma) {
	return 0.5 * sigma * Math.sqrt(2.0 * Math.PI) * x;
}

function calcGaussian(x, sigma) {
  return 1.0 / (sigma * Math.sqrt(2 * Math.PI)) * Math.exp(-Math.pow(x, 2) / (2 * Math.pow(sigma, 2)));
}

// sample from a standard normal, N(0,1)
function boxmueller() {
  return Math.sqrt(-2 * Math.log(Math.random())) * Math.cos(2 * Math.PI * Math.random());
}

// convert standard normal samples to scaled normal 
function sampleGaussian(sigma = 1.0) {
  return sigma * boxmueller();
}

function icdf(x, sigma) {
	if (x > 0.5) {
  	return Math.sqrt(-2.0 * Math.pow(sigma, 2) * Math.log(2.0 * (1.0 - x)));
  } else {
  	return Math.sqrt(-2.0 * Math.pow(sigma, 2) * Math.log(2.0 * x));
  }
}

function clean_random(x) {
	var eps = 0.0001
  if (x < eps) {x += eps;}					// too close to zero 
  if (x - 0.5 < eps) {x -= eps;}		// too close to 0.5
  if (0.5 - x < eps) {x += eps;}		// too close to 0.5
  if (1.0 - x < eps) {x -= eps;}		// too close to 1
  return x; 
} 


function getGradGaussianSamples(n_samples, sigma, antithetic) {
	var samples = [] 
  var f_x = []
  var p_x = []
  for (var i = 0; i < n_samples; i++) {
  	
    var rand = clean_random(Math.random());
    var x_i = icdf(rand, sigma) * (rand < 0.5 ? -1.0 : 1.0); 
    samples.push(x_i);
    
    if (antithetic) {
      var arand = 1.0 - rand; 
      var x_i = icdf(arand, sigma) * (arand < 0.5 ? -1.0 : 1.0); 
      samples.push(x_i);
    }
  }  
  
  // calculcate sample value and pdf 
  for (var i = 0; i<samples.length; i+=1){
    var f_xi = Math.abs(samples[i]) / Math.pow(sigma, 2) * calcGaussian(samples[i], sigma);
    var p_xi = 0.5 * sigma * Math.sqrt(2.0 * Math.PI) * f_xi;
    f_x.push(f_xi);
    p_x.push(p_xi); 
  }
  
  return [samples, f_x, p_x];
}

function getGaussianSamples(n_samples, sigma, antithetic) {
	var samples = []
  var p_x = []
  for (var i = 0; i < n_samples; i++) {
    var x_i = sampleGaussian(sigma);
    samples.push(x_i);
    if (antithetic) {samples.push(x_i * -1.0);}
  }
  
  // calc sample value 
  for (var i = 0; i < samples.length; i+=1) {
  	p_x.push(calcGaussian(samples[i], sigma=sigma));
  }
	return [samples, p_x]; 
}

function mc_estimate(f_x, p_x) {
	var N = f_x.length; 
  var estimate = 0.0; 
  for (var i = 0; i < N; i += 1) {
  	estimate += (f_x[i] / p_x[i]);
  }
  return estimate / N; 
}

function mse(x, y) {
	return Math.pow((x - y), 2); 
 } 

function convolve(theta, n_samples, samples, pdfs, sigma, goal) {
	var outputs = [];
  
  goal = 0.0; 		// after rendering! 
  
  var tmp = []
  for(var i = 0; i < n_samples; i+=1) {
  	var tau = samples[i];
    var w = gradGaussianKernel(tau, sigma);
    
    var theta_p = theta - tau; 
    var fn = stepEdge(theta_p);
    var weighted_fn_val = mse(fn, goal) * w; 
    
    outputs.push(weighted_fn_val); 
  }
  
  var final_estimate = mc_estimate(outputs, pdfs);
  return final_estimate;
}

function avg_list(vals) {
	var average = 0.0; 
	for (var i = 0; i < vals.length; i++) {
  	average += vals[i];
  }
  return average / vals.length; 
}


function optimize() {
	if (run_anim){return;}		// avoid double-running, e.g., when button is clicked while anim is running 
  
	sigma = parseFloat(sigmaSlider.value);
  var theta = parseFloat(thetaSlider.value); 
  var epochs = parseInt(epochsSlider.value);
  var stepsize = parseFloat(stepsizeSlider.value);
  var numSamples = parseInt(numSamplesSlider.value);
  var nsamples_real = antithetic_checkbox.checked ? Math.round(numSamples / 2.0) : numSamples; 

	run_anim = true; 
  Plotly.update('plot', {x: [[theta]], y: [[stepEdge(theta)]]}, {}, 2);
	Plotly.update('plot', {visible: true}, {}, 2);
	
  var gt_theta; gt_theta = 0.0; 
  
  let i = 0; 
  const updateTrace = () => {
    if (i < epochs && run_anim) {
      
      // get gradient by convolving and multiplying by kernel: 
      const [x_i, f_xi, p_xi] = getGradGaussianSamples(numSamples, sigma, antithetic_checkbox.checked);
    
      var grad = convolve(theta, nsamples_real, x_i, p_xi, sigma, gt_theta);
      
      // grad. descent step 
      theta -= stepsize * grad; 
    
    	var cost = mse(stepEdge(theta), gt_theta); 
      update_trajectory([theta, stepEdge(theta), cost]); 
      text_epochs.value = 'Current Epoch: ' + (i+1).toString(); 
      text_cost.value = 'Current Cost: ' + cost.toString() + '.0'; 
      
      // make timeout so that display is able to react 
      setTimeout(updateTrace, 5); 
      i++; 
    }
  }
  
  // call function 
  updateTrace(); 
 }
    
function update_trajectory(values){
  const traj = plot.data[2];
  var xData = traj.x;
	var yData = traj.y;
  xData.push(values[0]); 
  yData.push(values[1]);
  Plotly.update('plot', {x: [xData], y: [yData]}, {}, 2);
  update_triangle(values[0]); 
}


defaults = {'sigma': 1.0, 'nsamples': 10, 'epochs': 600, 'stepsize': 0.1, 'theta': -2.0};

// Define the data for the Gaussian distribution
var x = [], y_gauss = [], y_gradgauss = [], y_step = [], sigma = 1;
for (var i = -5; i < 5; i += 0.01) {
  x.push(i);
  y_step.push(stepEdge(i));
  y_gauss.push(calcGaussian(i, sigma = sigma));
  y_gradgauss.push(calcGradGaussian(i, sigma=sigma));
}

// Create the initial plot, declare all the traces 
var gaussianTrace = {
  x: x,
  y: y_gauss,
  name: 'Gaussian',
  type: 'scatter',
  opacity: 0.25
};
var gradGaussianTrace = {
  x: x,
  y: y_gradgauss,
  name: 'Grad. of Gaussian',
  type: 'scatter',
  marker: {color: 'rgb(0, 0, 0)'}
};
var stepTrace = {
  x: x,
  y: y_step,
  name: 'Cost Function',
  type: 'scatter',
  marker: {color: 'orange'}
};
var sampleTrace = {
    x: [],
    y: [],
    name: 'Samples',
    showlegend: false,
    mode: 'markers',
    opacity: 0.5,
    marker: {
      size: 7,
      symbol: 'diamond',
      color: 'black'
    }
};
var sampleTrace_gg = {
    x: [],
    y: [],
    name: 'Samples_gg',
    showlegend: false,
    mode: 'markers',
    opacity: 0.8,
    marker: {
      size: 7,
      symbol: 'diamond',
      color: 'black'
    }
};  
var smoothedFn = {
  x: [],
  y: [],
  name: 'Smoothed',
  type: 'scatter',
  marker: {color: 'rgb(255, 0, 255)'}
};
var verticalZero = {
  x: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
  y: [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
  name: '',
  showlegend: false,
  type: 'scatter',
  opacity: 0.75,
  line: {color: 'black', 'width': 0.5},
};
var pxTrace = {
  x: [-5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1, 2, 3, 4, 5, -5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1, 2, 3, 4, 5],
  y: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  name: '',
  showlegend: false,
  type: 'scatter',
  opacity: 0.75,
  marker: {color: 'black', size: 2, line: {color: 'black', width: 2}}
};
var trajectory = {
	x: [defaults.theta], 
  y: [1.0], 
  name: 'Triangle Center', 
  type: 'scatter', 
  mode: 'markers',
  marker: {color: 'lime', size: 10, line: {color: 'grey', width: 1}}
};
var layout = {
  responsive: true,
  title: '1D Example: Differentiating Through Plateaus',
  xaxis: {title: 'x', 'range': [-5, 5], zeroline: false},
  yaxis: {title: 'y', 'range': [-0.1, 1.2]},
  legend: {orientation: 'h', y: 0.0, xanchor: 'center', x: 0.5},
  /*shapes: [{type: 'rect',
           xref: 'x',
           yref: 'paper',
           x0: -1.5,
           y0: 0.075,
           x1: 1.5,
           y1: 0.15,
           fillcolor: 'royalblue',
           opacity: 0.6,
           layer: 'below',
           line: {width: 0}}],*/
};
var layoutLower = {
  responsive: true,
  xaxis: {title: '', 'range': [-5, 5]},
  yaxis: {title: '', 'range': [-0.1, 1.2]},
  legend: {orientation: 'h', y: 0.0, xanchor: 'center', x: 0.5},
  margin: {t: 10, b: 10, l: 25, r: 10},
  autosize: true
};
var layoutPxPlot = {
  responsive: true,
  xaxis: {title: '', 'range': [-5, 5], zeroline: false, showgrid: false},
  yaxis: {title: '', 'range': [-0.2, 0.7], showgrid: false, tickmode: 'array', tickvals: [0],
    showticklabels: false},
  legend: {orientation: 'h', y: 0.0, xanchor: 'center', x: 0.5},
  margin: {t: 2, b: 2, l: 80, r: 80},
  shapes: [{type: 'path',
      			path: 'M 0 0 L 1 0.4 L 2 0 Z',
      			xref: 'x',
      			yref: 'y',
      			fillcolor: 'red',
      			opacity: 0.6,
      			line: {width: 1}}, 
      		 {type: 'rect',
            xref: 'x',
            yref: 'y',
            x0: 0.80,
            y0: 0.0,
            x1: 1.2,
            y1: 0.2,
            fillcolor: 'grey',
            opacity: 0.6,
            line: {width: 1}}],
};

Plotly.newPlot('plot', [stepTrace, 
                        smoothedFn,
                        trajectory], layout);
Plotly.newPlot('plot2', [gaussianTrace,
                         gradGaussianTrace,
                         sampleTrace,
                         sampleTrace_gg,verticalZero], layoutLower);
Plotly.newPlot('plot3', [pxTrace], layoutPxPlot);
                        
function reset_textboxes() {
	text_cost.value = 'Current Cost: 1.0'; 
  text_epochs.value = 'Current Epoch: 0';
}

function reset(incl_plots=true) {
	sigmaSlider.value = defaults.sigma; 
  thetaSlider.value = defaults.theta;
  epochsSlider.value = defaults.epochs; 
  stepsizeSlider.value = defaults.stepsize; 
  numSamplesSlider.value = defaults.nsamples; 
  smoothed_checkbox.checked = false;
  antithetic_checkbox.checked = true;
  reset_textboxes(); 
  update_triangle();
  if (incl_plots) update_plots();
}

var sigmaSlider = document.getElementById('sigma');
var thetaSlider = document.getElementById('theta');
var epochsSlider = document.getElementById('epochs');
var stepsizeSlider = document.getElementById('stepsize');
var numSamplesSlider = document.getElementById('num-samples');
var smoothed_checkbox = document.getElementById('cb_showsmoothed');
var antithetic_checkbox = document.getElementById('cb_antithetic');

var text_cost = document.getElementById('cost_text')
var text_epochs = document.getElementById('epoch_text')

reset(incl_plots=false); 		// set default values to sliders 

var run_anim = false; 

thetaSlider.addEventListener('input', function() {
	update_triangle()
  update_plots(resample=false);
  stop_anim(); 
  reset_textboxes(); 
});

[epochsSlider, stepsizeSlider].forEach(function(element) {
   element.addEventListener('input', function() {
      update_plots(resample=false);
      stop_anim(); 
      reset_textboxes(); 
   });
});

[sigmaSlider, numSamplesSlider,antithetic_checkbox, smoothed_checkbox].forEach(function(element) {
   element.addEventListener('input', function() {
      update_plots(resample=true);
      stop_anim(); 
      reset_textboxes(); 
   });
});

function stop_anim() {
	run_anim = false; 
}

function theta_to_triPath(th) {
	// expects a single theta parameter, returns a triangle path that is used to update the layout 
  var w = 1.4; 		// tri width 
  var y = 0.0; 
  var h = 0.5; 
  var tripath = 'M ' + (th-w).toString() + ' ' + y.toString() + ' L ' + th.toString() + ' ' + (y+h).toString() + ' L ' + (th+w).toString() + ' '+ y.toString() +' Z';
  return tripath; 
}

function update_triangle(theta=999) {
	if (theta==999) {
		theta = parseFloat(thetaSlider.value); 		// default value, never passed, read from slider 
  }
  var tripath = theta_to_triPath(theta); 
  var update = {'shapes[0].path': tripath};
  Plotly.relayout('plot3', update);
}

function update_plots(resample=true){
	
  if (!smoothed_checkbox.checked) {Plotly.update('plot', {visible: false}, {}, 1);}
  else {Plotly.update('plot', {visible: true}, {}, 1);}
  
  sigma = parseFloat(sigmaSlider.value);
  var theta_init = parseFloat(thetaSlider.value);
  var numSamples = parseInt(numSamplesSlider.value);
  
  // remove (potential) trajectory 
  Plotly.update('plot', {visible: true}, {}, 2);
  Plotly.update('plot', {x: [[theta_init]], y: [[stepEdge(theta_init)]]}, {}, 2); 
  
  // update gaussian plots: for gradgaussian, plot pdf, to have same scale easier 
  for (var i = 0; i < x.length; i++) {
    y_gauss[i] = calcGaussian(x[i], sigma = sigma);
    y_gradgauss[i] = 0.5 * sigma * Math.sqrt(2.0 * Math.PI) * calcGradGaussian(x[i], sigma=sigma);		
  }
  Plotly.update('plot2', {y: [y_gauss]}, {}, 0,);				// {} is update for layout, 0 is selector index
  Plotly.update('plot2', {y: [y_gradgauss]}, {}, 1,);		// {} is update for layout, 0 is selector index
  
  
    // update samples: get samples and update the plots 
    var nsamples_real = antithetic_checkbox.checked ? Math.floor(numSamples / 2.0) : numSamples; 
    if (resample) {
    const [xsampled_gauss, ysampled_gauss] = getGaussianSamples(nsamples_real, sigma, antithetic_checkbox.checked);
    const [x_gradG, y_gradG, pdf_gradG] = getGradGaussianSamples(nsamples_real, sigma, antithetic_checkbox.checked);
  
    Plotly.update('plot2', {x: [xsampled_gauss], y: [ysampled_gauss]}, {}, 2);		
    Plotly.update('plot2', {x: [x_gradG], y: [pdf_gradG]}, {}, 3);
  }
  
  if (!smoothed_checkbox.checked) {
  	return;
  } else {
  	if (!resample) {return;}
  
    // go through all x's, for every x make a "smoothed" y-val by sampling N pts from the current
    // x coordinate, and then query and avg their fn val 
    var smoothed = []
    for(var i = 0; i < x.length; i+=1) {
      var theta = x[i]		// go from -5 to 5 

			// we concolve with the Gaussian, not the grad.gaussian! 
      //const [xg, yg, pdf_g] = getGradGaussianSamples(nsamples_real, sigma, antithetic_checkbox.checked);
      const [xg, yg] = getGaussianSamples(nsamples_real, sigma, antithetic_checkbox.checked);

      var fn_avg; fn_avg = 0.0;
      for (var j=0; j < xg.length; j+=1) {
        var theta_perturbed = theta - xg[j]; 
        fn_avg += stepEdge(theta_perturbed);
      }

      smoothed.push(fn_avg / numSamples); 
    }

    Plotly.update('plot', {x: [x], y: [smoothed]}, {}, 1);
  }
}


</script>
<br />

<p style="text-align: justify">
We also provide a simple 2D example of our method in <a href="https://colab.research.google.com/github/mfischer-ucl/prdpt/blob/main/examples/box_example.ipynb">Colab</a>. Here, we optimize a square that, in the initial configuration, 
does not overlap its reference and hence creates a plateau in the loss landscape (the 2D counterpart to the example above). This example uses a simpler renderer 
and hence does not need all the scene config / rendering infrastructure used in the main repository.
</p>
<div style="display: flex; justify-content: center; align-items: center; margin-top: 2%; max-width: 100%">
  <img src="/assets/images/prdpt/2Dexample.png" style="max-width: 90%;" />
</div>

<br />

<b>Results</b><br />
<p style="text-align: justify">
In the paper, we show a variety of results on different inverse rendering tasks. One such example is included here:  
we optimize the position of the red sphere (cf. the video below) that is initially occluded by the blue sphere. This  
leads to a jump discontinuity as soon as the red sphere moves in front of the blue one (cf. the sudden change in the image loss plot)
with plateaus to the left and right. As in the interactive example above, our method (blue) successfully smoothes the space
and differentiates through the plateaus, whereas a rigid optimization (orange) gets stuck on the plateau. 
</p>

<div class="vidcontainer">
    <video id="occl-vid" style="display:inline-block; width:95%;" autoplay="" muted="" loop="" controls="">
      <source src="/assets/images/prdpt/occl_w_graph.webm" type="video/webm" />
      Your browser does not support the video tag.
    </video>
</div>

<p style="text-align: justify">
Another example of our method shows how a smoother space is easier to optimize: the rigid optimization (the orange curve in the plot) follows 
the slight slope leading to a wrong minimum and finally pushing the sphere out of the image, where a plateau is hit, 
and the optimizer cannot recover. Our formulation (the blue curve) allows the optimization to converge, as it is operating in a smoother space.   
</p>

<div class="vidcontainer">
    <video id="shad-vid" style="display:inline-block; width: 95%;" autoplay="" muted="" loop="" controls="">
      <source src="/assets/images/prdpt/shadows_w_graph.webm" type="video/webm" />
      Your browser does not support the video tag.
    </video>
</div>

<p style="text-align: justify">
In the below example the task is to optimize the light's position such that a reference caustic is matched. 
As in the shadow example, the rigid optimization operates in non-smooth space, and pushes the light source far out, 
where a plateau (the grey image) is reached. Our method operates in smooth space and finds the correct position.
</p>

<div class="vidcontainer">
    <video id="caust-vid" style="display:inline-block; width: 95%;" autoplay="" muted="" loop="" controls="">
      <source src="/assets/images/prdpt/caustic_w_graph.webm" type="video/webm" />
      Your browser does not support the video tag.
    </video>
</div>


<br />

<b>BibTeX</b><br />
If you find our work useful and use parts or ideas of our paper or code, please cite: <br />
<p class="cite-box" style="margin-top: 5px">
  <span style="font-family: Lucida Console, Courier New, monospace; padding: 10px;">
    @inproceedings{fischer2023plateau, <br />
      &nbsp;&nbsp;title={Plateau-Reduced Differentiable Path Tracing}, <br /> 
      &nbsp;&nbsp;author={Fischer, Michael and Ritschel, Tobias}, <br />
      &nbsp;&nbsp;booktitle={Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition}, <br />
      &nbsp;&nbsp;pages={4285--4294}, <br />
      &nbsp;&nbsp;year={2023} <br />
    }
  </span>
</p>


<b>Acknowledgements</b><br />
We thank the Chen Liu, Valentin Deschaintre and the anonymous reviewers for their constructive comments and insightful 
feedback. We further thank Meta Reality Labs for supporting and enabling this research.  

</div>
</body>

        
      </section>

      <footer class="page__meta">
        
        


        

      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2023 Michael Fischer. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
